#include <windows.h>
#include <iostream>

constexpr SIZE_T PAGE_SIZE  = 4096;
constexpr SIZE_T BLOCK_SIZE = 64;
constexpr SIZE_T NUM_BLOCKS = PAGE_SIZE / BLOCK_SIZE;

struct FreeNode {
    FreeNode* next;
};



struct MemoryPool {
    void* memory;             // VirtualAlloc region
    FreeNode* freeList;       // Head of free list
    CRITICAL_SECTION lock;    // Thread safety
};

#* is the pointer
#void* is the pointer to a data of unknown type
# void* memory is to create a varible called memory which is a pointer to data of unspecified type
# FreeNode* next is to create a variable called next which is a pointer to a Freenode.
        #this "next" varible needs to be assigned a value either manually or dynamically

#CRITICAL_SECTION is declared in windows.h
#CRITICAL_SECTION lock is a windows sync primitive: it ensures only 1 thread at a time can use the allocated memory
        # it protects updates to freeList, possibly resizing the pool, and any operations that are thread safe
        # faster than a win32 mutex, but still provides mutual exclusion withing a process

#EnterCriticalSection(&pool.lock) is to be used every time a thread wants to enter (lock) the CriticalSecion
#InitializeCriticalSection(&pool.lock) is called only once, during program startup





MemoryPool pool;

// ------------------- Pool Initialization -------------------

bool InitializePool() {
    pool.memory = VirtualAlloc(
        nullptr,
        PAGE_SIZE,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE
    );
#MEM_RESERVE a flag to tell VirtualAlloc to find unsued space and not let other allocation use it
#MEM_COMMIT is to tell VirtuallAlloc to make this memory space usable

#the flag MEM_RESERVE and MEM_COMMIT are bitwise, meaning they are 1s and 0s. 
#if you want to use both -> add the value of 1s and 0s (like Union) to get a value for the combination of both MEM_RESERVE and MEM_COMMIT
# if you use (&) instead of (|), you only take the 1s and 0s that are in both flag (like intersection) -> might become null -> no flag




    if (!pool.memory) {
        std::cerr << "VirtualAlloc failed: " << GetLastError() << "\n";
        return false;
    }

    InitializeCriticalSection(&pool.lock);

    pool.freeList = nullptr;

    // Build the free list
    char* base = static_cast<char*>(pool.memory);

    for (size_t i = 0; i < NUM_BLOCKS; i++) {
        char* blockAddr = base + i * BLOCK_SIZE;
        FreeNode* node = reinterpret_cast<FreeNode*>(blockAddr);
        node->next = pool.freeList;
        pool.freeList = node;
    }

    return true;
}

# in detail: blockAddr is a char*, pointing to the start of a 64-byte block
#            reinterpret_cast<FreeNode*> simply tells the compiler to treat this address as a pointer and store it as "node" which is the pointer to the new found node
# in a 64bit system, only the first 8 bytes are treated as a pointer, the rest (56 bytes) is for the user to use

# node-> means access a member inside a struct pointed to by "node"
# node-> next = pool.freeList; means go inside the new found node, go to the allocated memory "next" and assign it the value of pool.freeList
# so basically, till now, the code iterates to the next block, stores its address as "node", assigns the "next" member(inside this node) the address of current freeList 
# then pool.freeList =node; is to make this new node become the head of the freeList 
#--> the freeList list will be in reverse order of the block list

#char* base is to create a variable called base pointing to the address of a char. using char gives the precise location coz char is 1 byte
#char* allows byte-wise pointer arithmetic, meaning adding 1 to a char* moves the pointer by exactly 1 byte







// ------------------------- Allocate -------------------------

void* PoolAlloc() {
    EnterCriticalSection(&pool.lock);

    if (!pool.freeList) {
        LeaveCriticalSection(&pool.lock);
        return nullptr; // Out of memory
    }

    FreeNode* node = pool.freeList;
    pool.freeList = node->next;

    LeaveCriticalSection(&pool.lock);
    return node;
}

// --------------------------- Free ---------------------------

void PoolFree(void* ptr) {
    EnterCriticalSection(&pool.lock);

    FreeNode* node = static_cast<FreeNode*>(ptr);
    node->next = pool.freeList;
    pool.freeList = node;

    LeaveCriticalSection(&pool.lock);
}

// ----------------------- Worker Thread ----------------------

DWORD WINAPI Worker(LPVOID) {
    for (int i = 0; i < 1000; i++) {

        void* mem = PoolAlloc();
        if (mem) {
            // Simulate work
            memset(mem, 0xAB, BLOCK_SIZE);
            Sleep(1);
            PoolFree(mem);
        } else {
            std::cout << "Out of memory!\n";
        }
    }
    return 0;
}

// --------------------------- Main ---------------------------

int main() {
    if (!InitializePool()) {
        return 1;
    }

    // Create threads
    HANDLE threads[4];
    for (int i = 0; i < 4; i++) {
        threads[i] = CreateThread(nullptr, 0, Worker, nullptr, 0, nullptr);
    }

    // Wait for them
    WaitForMultipleObjects(4, threads, TRUE, INFINITE);

    // Cleanup
    for (HANDLE t : threads)
        CloseHandle(t);

    DeleteCriticalSection(&pool.lock);
    VirtualFree(pool.memory, 0, MEM_RELEASE);

    std::cout << "All done.\n";
    return 0;
}





#uncommented version
#include <windows.h>
#include <iostream>

constexpr SIZE_T PAGE_SIZE = 4096;
constexpr SIZE_T BLOCK_SIZE = 64;
constexpr SIZE_T NUM_BLOCKS = PAGE_SIZE / BLOCK_SIZE;

struct FreeNode {
    FreeNode* next;
};

struct MemoryPool {
    void* memory;
    FreeNode* freeList;
    CRITICAL_SECTION lock;
};

MemoryPool pool;

bool InitializePool() {
    pool.memory = VirtualAlloc(
        nullptr,
        PAGE_SIZE,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE
    );

    if (!pool.memory) {
        std::cerr << "VirtualAlloc failed: " << GetLastError() << "\n";
        return false;
    }

    InitializeCriticalSection(&pool.lock);

    pool.freeList = nullptr;

    char* base = static_cast<char*>(pool.memory);
    for (size_t i = 0; i < NUM_BLOCKS; i++) {
        char* blockAddr = base + i * BLOCK_SIZE;
        FreeNode* node = reinterpret_cast<FreeNode*>(blockAddr);
        node->next = pool.freeList;
        pool.freeList = node;
    }

    return true;
}

// Allocate a block
void* AllocateBlock() {
    EnterCriticalSection(&pool.lock);
    if (!pool.freeList) {
        LeaveCriticalSection(&pool.lock);
        return nullptr; // pool exhausted
    }

    FreeNode* node = pool.freeList;
    pool.freeList = node->next;
    LeaveCriticalSection(&pool.lock);
    return node;
}

// Free a block
void FreeBlock(void* ptr) {
    EnterCriticalSection(&pool.lock);
    FreeNode* node = reinterpret_cast<FreeNode*>(ptr);
    node->next = pool.freeList;
    pool.freeList = node;
    LeaveCriticalSection(&pool.lock);
}

int main() {
    if (!InitializePool()) {
        return 1;
    }

    void* a = AllocateBlock();
    void* b = AllocateBlock();

    FreeBlock(a);
    FreeBlock(b);

    DeleteCriticalSection(&pool.lock);
    VirtualFree(pool.memory, 0, MEM_RELEASE);

    return 0;
}

