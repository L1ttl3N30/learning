#include <windows.h>
#include <iostream>

constexpr SIZE_T PAGE_SIZE  = 4096;
constexpr SIZE_T BLOCK_SIZE = 64;
constexpr SIZE_T NUM_BLOCKS = PAGE_SIZE / BLOCK_SIZE;

struct FreeNode {
    FreeNode* next;
};



struct MemoryPool {
    void* memory;             // VirtualAlloc region
    FreeNode* freeList;       // Head of free list
    CRITICAL_SECTION lock;    // Thread safety
};

#* is the pointer
#void* is the pointer to a data of unknown type
# void* memory is to create a varible called memory which is a pointer to data of unspeci>
# FreeNode* next is to create a variable called next which is a pointer to a Freenode.
        #this "next" varible needs to be assigned a value either manually or dynamically

#CRITICAL_SECTION is declared in windows.h
#CRITICAL_SECTION lock is a windows sync primitive: it ensures only 1 thread at a time ca>
        # it protects updates to freeList, possibly resizing the pool, and any operation >
        # faster than a win32 mutex, but still provides mutual exclusion withing a process

#EnterCriticalSection(&pool.lock) is to be used every time a thread wants to enter (lock)>
#InitializeCriticalSection(&pool.lock) is called only once, during program startup





MemoryPool pool;

// ------------------- Pool Initialization -------------------

bool InitializePool() {
    pool.memory = VirtualAlloc(
        nullptr,
        PAGE_SIZE,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE
    );
#MEM_RESERVE a flag to tell VirtualAlloc to find unsued space and not let other allocatio>
#MEM_COMMIT is to tell VirtuallAlloc to make this memory space usable

#the flag MEM_RESERVE and MEM_COMMIT are bitwise, meaning they are 1s and 0s. 
#if you want to use both -> add the value of 1s and 0s (like Union) to get a value for th>
# if you use (&) instead of (|), you only take the 1s and 0s that are in both flag (like >




    if (!pool.memory) {
        std::cerr << "VirtualAlloc failed: " << GetLastError() << "\n";
        return false;
    }

    InitializeCriticalSection(&pool.lock);

    pool.freeList = nullptr;

    // Build the free list
    char* base = static_cast<char*>(pool.memory);

    for (size_t i = 0; i < NUM_BLOCKS; i++) {
        char* blockAddr = base + i * BLOCK_SIZE;
        FreeNode* node = reinterpret_cast<FreeNode*>(blockAddr);
        node->next = pool.freeList;
        pool.freeList = node;
    }

    return true;
}

# in detail: blockAddr is a char*, pointing to the start of a 64-byte block
#            reinterpret_cast<FreeNode*> simply tells the compiler to treat this address >
# in a 64bit system, only the first 8 bytes are treated as a pointer, the rest (56 bytes)>

# node-> means access a member inside a struct pointed to by "node"
# node-> next = pool.freeList; means take the current address of freeList, write it into >
 
#char* base is to create a variable called base pointing to the address of a char. using >
# char* blockAddr = base + i * BLOCK_SIZE; is to calculate the bytes after base ->compute>
#FreeNode* node = reinterpret_cast<FreeNode*>(blockAddr); is to turn each block into a Fr>







// ------------------------- Allocate -------------------------

void* PoolAlloc() {
    EnterCriticalSection(&pool.lock);

    if (!pool.freeList) {
        LeaveCriticalSection(&pool.lock);
        return nullptr; // Out of memory
    }

    FreeNode* node = pool.freeList;
    pool.freeList = node->next;

    LeaveCriticalSection(&pool.lock);
    return node;
}

// --------------------------- Free ---------------------------

void PoolFree(void* ptr) {
    EnterCriticalSection(&pool.lock);

    FreeNode* node = static_cast<FreeNode*>(ptr);
    node->next = pool.freeList;
    pool.freeList = node;

    LeaveCriticalSection(&pool.lock);
}

// ----------------------- Worker Thread ----------------------

DWORD WINAPI Worker(LPVOID) {
    for (int i = 0; i < 1000; i++) {

        void* mem = PoolAlloc();
        if (mem) {
            // Simulate work
            memset(mem, 0xAB, BLOCK_SIZE);
            Sleep(1);
            PoolFree(mem);
        } else {
            std::cout << "Out of memory!\n";
        }
    }
    return 0;
}

// --------------------------- Main ---------------------------

int main() {
    if (!InitializePool()) {
        return 1;
    }

    // Create threads
    HANDLE threads[4];
    for (int i = 0; i < 4; i++) {
        threads[i] = CreateThread(nullptr, 0, Worker, nullptr, 0, nullptr);
    }

    // Wait for them
    WaitForMultipleObjects(4, threads, TRUE, INFINITE);

    // Cleanup
    for (HANDLE t : threads)
        CloseHandle(t);

    DeleteCriticalSection(&pool.lock);
    VirtualFree(pool.memory, 0, MEM_RELEASE);

    std::cout << "All done.\n";
    return 0;
}





#uncommented version
#include <windows.h>
#include <iostream>

constexpr SIZE_T PAGE_SIZE = 4096;
constexpr SIZE_T BLOCK_SIZE = 64;
constexpr SIZE_T NUM_BLOCKS = PAGE_SIZE / BLOCK_SIZE;

struct FreeNode {
    FreeNode* next;
};

struct MemoryPool {
    void* memory;
    FreeNode* freeList;
    CRITICAL_SECTION lock;
};

MemoryPool pool;

bool InitializePool() {
    pool.memory = VirtualAlloc(
        nullptr,
        PAGE_SIZE,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE
    );

    if (!pool.memory) {
        std::cerr << "VirtualAlloc failed: " << GetLastError() << "\n";
        return false;
    }

    InitializeCriticalSection(&pool.lock);

    pool.freeList = nullptr;

    char* base = static_cast<char*>(pool.memory);
    for (size_t i = 0; i < NUM_BLOCKS; i++) {
        char* blockAddr = base + i * BLOCK_SIZE;
        FreeNode* node = reinterpret_cast<FreeNode*>(blockAddr);
        node->next = pool.freeList;
        pool.freeList = node;
    }

    return true;
}

// Allocate a block
void* AllocateBlock() {
    EnterCriticalSection(&pool.lock);
    if (!pool.freeList) {
        LeaveCriticalSection(&pool.lock);
        return nullptr; // pool exhausted
    }

    FreeNode* node = pool.freeList;
    pool.freeList = node->next;
    LeaveCriticalSection(&pool.lock);
    return node;
}

// Free a block
void FreeBlock(void* ptr) {
    EnterCriticalSection(&pool.lock);
    FreeNode* node = reinterpret_cast<FreeNode*>(ptr);
    node->next = pool.freeList;
    pool.freeList = node;
    LeaveCriticalSection(&pool.lock);
}

int main() {
    if (!InitializePool()) {
        return 1;
    }

    void* a = AllocateBlock();
    void* b = AllocateBlock();

    FreeBlock(a);
    FreeBlock(b);

    DeleteCriticalSection(&pool.lock);
    VirtualFree(pool.memory, 0, MEM_RELEASE);

    return 0;
}

