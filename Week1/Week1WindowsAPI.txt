1. What APIS do
- like any other functions:
	change data structures
	read,write,modify,delete
	control, read or write to devices
	implement some algorithms/logic

2. example of using apis to call notepad
- when you write a C++ program to use win apis to open notepad.exe
	+ you pass higher-level parameters to the OS
	+ these parameters are used by the OS to build PEB
		 PEB has a fixed data structure
		 When CreateProcess alls down to NTCreateUSerProcess, the kernel:
			allocates a new process object (Eprocess)
			creates a new address space
			map the exe image into memory
			allocates memory for a PEB and fills it with
				image base address
				loader data
				process parameters (passed from args)
				default head point,....
	+ then the OS allocates a TEB (thread environment block)
	+ sets up the initial thread stack and cpu context


| **Cooking analogy**                                                                                                                 | **What happens in Windows**                                                                                                                   |
| ----------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| ðŸ§¾ **You (the caller) list the ingredients** â€” you say *what dish you want* and *what ingredients to use* (e.g., flour, salt, oil). | You call **`CreateProcess`** and pass arguments â€” the **path to the EXE**, **command line**, **environment variables**, and **startup info**. |
| ðŸ‘¨â€ðŸ³ **The chef** knows the **recipe** â€” he knows the sequence of steps to prepare that dish.                                      | The **Windows kernel + loader (NTDLL)** have a **fixed recipe** â€” the sequence of internal steps for process creation and initialization.     |
| ðŸ² **The chef takes a new pot** â€” clean, isolated, ready to use.                                                                    | The OS **creates a new address space** â€” an empty, isolated memory map (this is your â€œnew potâ€).                                              |
| ðŸ”¥ **He puts the pot on the stove** â€” assigns it to a burner to be cooked.                                                          | The kernel **registers the process and thread** with the scheduler â€” gives them CPU time and system resources.                                |
| ðŸ¥• **He fills the pot with ingredients** â€” using your ingredient list.                                                              | The kernel + NTDLL **fill the new processâ€™s memory** (PEB, parameters, environment, loaded image) using your inputs.                          |
| ðŸ§‘â€ðŸ³ **The chef starts cooking** â€” begins the cooking process.                                                                     | The **primary thread starts executing**, running the processâ€™s startup code (like `_NtProcessStartup â†’ mainCRTStartup â†’ main`).               |


3. ntdll.dll is user-mode code. It contains the user-side implementations of low-level Windows APIs and the syscall wrappers 
â€” tiny functions that set up CPU registers and execute the instruction 
that causes a controlled transition into kernel mode (on x86/x64 thatâ€™s syscall/sysenter/int 2e historically).

So think of ntdll as the user-side gateway: it provides the userland functions that applications call, 
and those functions invoke the kernel via the syscall mechanism. ntdll itself runs in user mode (Ring 3); the kernel code that actually services the syscall runs in Ring 0.

4.kernel is privileged system software that manages hardware and resources and provides abstractions to user programs. Roles of the kernel include:

Managing CPU scheduling, memory, processes/threads.

Abstracting hardware through drivers (so applications donâ€™t need to know device specifics).

Enforcing security and isolation (access checks, privilege separation).

Providing core services (file systems, networking stacks, IPC).

The kernel itself doesnâ€™t directly toggle every hardware pin â€” it calls drivers that know how to talk to specific hardware. 
It exposes higher-level primitives (read, write, DMA setup, interrupts) that drivers use to control hardware. 
The kernel runs at a privileged CPU mode so it can perform operations user code cannot.



5. A driver is programmatic code that enables the OS to use hardware (or expose virtual devices)
- signing a driver is just for knowing who made the driver, not whether is safe to use
- 64-bit Windows (modern versions) enforces kernel-mode driver signing by default
- Secure Boot and other platform protections can further restrict loading unsigned or improperly signed kernel modules
- on older or unsupported Windows versions, unsigned drivers can often be loaded and executed, because driver-signing enforcement was weaker or absent


6. ***three layers: API (user-facing) â†’ syscall (mechanism/transition) â†’ system service (kernel implementation
- ntdll is at api level, edr hooks ntdll to check for malicious intent
- but you can do syscall without using ntdll, but you need to know syscall id -> hell's gate technique can retrieve syscall id


7. Hooking is any technique that intercepts or redirects calls/messages/events so you can observe, modify, or replace behavior. Common kinds:

User-mode function hook: change a function pointer or patch the start of a function (its prologue) so calls end up at your code first. Example: replacing the address in an Import Address Table (IAT) or overwriting the first bytes of a function.

Kernelâ€mode hook: intercept kernel callbacks, swap function pointers in kernel structures, or register callback hooks (e.g., process creation callbacks).

API/ABI interception: intercepting calls at the ntdll boundary (the syscall wrappers) so you see syscalls before they go into the kernel.

Unhooking commonly means restoring the original bytes/function pointer 
so the function behaves as originally intended (remove the interception). 
In defensive contexts, â€œunhookingâ€ can also mean restoring a library to a known-good state if it was tampered with.


8. windows becomes more safe -> harder for defensive edr too, not just hackers

9. the flow of a command in windows is:
- API is called
- API wraps the data, sends it to the kernel
- kernel manages memory, access rights,..then talks to the driver
- basically the kernel says "hey driver, read these sectors from this device"
- driver sends commands to the firmware
- the firmware makes the hardwares act
