Excellent â€” now weâ€™ll integrate the **API layer**, **kernel**, **driver**, and **firmware** levels into the process creation chain so you can see *where* each one fits and *what* role it plays.

## ğŸ§© **The Full Chain: From API to Firmware**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   USER MODE: Application & API Layer                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Explorer.exe (the Shell)                                                 â”‚
â”‚    â†“ calls â†’ Shell32.dll (ShellExecuteExW)                                  â”‚
â”‚    â†“ calls â†’ Kernel32.dll (CreateProcessW)                                  â”‚
â”‚    â†“ calls â†’ NTDLL.dll (NtCreateUserProcess - Native API)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚  (syscall)
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   KERNEL MODE: Windows Executive                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. NtCreateUserProcess â†’ Kernel transition (via SYSCALL instruction)        â”‚
â”‚ 3. Process Manager (Ps) creates EPROCESS / ETHREAD objects                  â”‚
â”‚ 4. Object Manager opens file handles                                        â”‚
â”‚ 5. Memory Manager maps image into new address space                         â”‚
â”‚ 6. Security subsystem applies access tokens                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   KERNEL MODE: Drivers & I/O Stack                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - I/O Manager passes file open requests to File System Drivers (NTFS.sys)   â”‚
â”‚ - NTFS.sys communicates with Storage Drivers (disk.sys, storport.sys, etc.) â”‚
â”‚ - These drivers issue IRPs (I/O Request Packets) to interact with hardware  â”‚
â”‚ - The drivers read the .exe pages from disk into system cache / memory      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   HARDWARE & FIRMWARE LEVEL                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - The Storage Controller and Disk (hardware) respond to driver requests     â”‚
â”‚ - DMA or bus transfers move code pages into RAM                             â”‚
â”‚ - Firmware (e.g., UEFI) initialized these hardware interfaces during boot   â”‚
â”‚   but does not participate directly here                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   BACK TO USER MODE                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 7. Kernel returns to NTDLL; user-mode loader (LdrInitializeThunk) runs      â”‚
â”‚ 8. Loads dependent DLLs, resolves imports, sets up heaps & stacks           â”‚
â”‚ 9. Transfers control to programâ€™s entry point (WinMain/main)                â”‚
â”‚ 10. CPU executes user instructions via fetchâ€“decodeâ€“execute cycle           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ” **Narrative Summary by Layer**

### ğŸ§± **1. API Layer (User Mode)**

* **Explorer.exe**, the Windows shell, is part of the Win32 API layer.
* When you double-click an `.exe`, it calls functions like:

  * `ShellExecuteExW` (in `Shell32.dll`)
  * `CreateProcessW` (in `Kernel32.dll`)
* These APIs abstract the NT system calls and prepare parameters for the kernel.

ğŸ’¡ *Purpose:* Provide a user-friendly, high-level interface to the OS.

---

### âš™ï¸ **2. Native System Layer (NTDLL + System Call)**

* `NtCreateUserProcess` in `NTDLL.dll` invokes a **system call** to enter **kernel mode**.
* This is the bridge between user-mode API and kernel-mode Executive components.

ğŸ’¡ *Purpose:* Translate user-mode API requests into low-level kernel calls.

---

### ğŸ§© **3. Kernel (Windows Executive)**

* Once in kernel mode:

  * **Process Manager (Ps)** creates process and thread objects (`EPROCESS`, `ETHREAD`).
  * **Object Manager** handles handles, namespaces, and access rights.
  * **Memory Manager (Mm)** sets up virtual address space and maps image sections.
  * **Security Reference Monitor** applies access checks.
* These components make up the **Windows Executive**, all running in kernel mode.

ğŸ’¡ *Purpose:* Manage processes, memory, objects, and security at the system level.

---

### ğŸ”Œ **4. Drivers & I/O System**

* The **I/O Manager** coordinates requests with kernel-mode **drivers**:

  * **NTFS.sys** reads executable pages from disk.
  * **Disk.sys** and **StorPort.sys** communicate with the storage controller.
  * **Bus drivers** (like PCI, SATA, NVMe) and **miniport drivers** perform low-level hardware I/O.
* Data (the executable code) is transferred from the storage device into RAM, often using **DMA (Direct Memory Access)**.

ğŸ’¡ *Purpose:* Handle all hardware communication and move executable data into memory.

---

### ğŸ§¬ **5. Firmware Level (UEFI / BIOS)**

* The **firmware** (UEFI/BIOS) initialized all hardware at boot time and exposed standard interfaces the OS uses.
* Itâ€™s *not* involved in launching Notepad, but the drivers depend on the hardware and memory maps that firmware configured.

ğŸ’¡ *Purpose:* Prepare the hardware and environment before Windows boots.

---

### ğŸ–¥ï¸ **6. User-mode Loader & Execution**

* Control returns to user mode, where `ntdll!LdrInitializeThunk` loads dependent DLLs (like `user32.dll`, `gdi32.dll`, etc.).
* After relocations and import resolution, the loader jumps to the processâ€™s **entry point**.
* The **CPU** now executes your program instructions, with:

  * The **MMU** translating virtual â†’ physical addresses.
  * The **cache hierarchy** (L1/L2/L3) optimizing access speed.

ğŸ’¡ *Purpose:* Bring the process fully alive and begin executing code.

---

## ğŸ§® **Final Summary Table**

| Layer            | Component                     | Key Example                                   | Description                                                        |
| ---------------- | ----------------------------- | --------------------------------------------- | ------------------------------------------------------------------ |
| **API Layer**    | Shell & Win32 API             | `Explorer.exe`, `Shell32.dll`, `Kernel32.dll` | High-level functions to create a process.                          |
| **Native Layer** | NTDLL                         | `NtCreateUserProcess`                         | Performs system call transition to kernel mode.                    |
| **Kernel**       | Windows Executive             | Process Manager, Memory Manager               | Creates EPROCESS/ETHREAD, sets up memory, initializes environment. |
| **Drivers**      | I/O, File System, Bus Drivers | `NTFS.sys`, `disk.sys`, `storport.sys`        | Read executable data from disk into RAM.                           |
| **Firmware**     | UEFI / BIOS                   | Motherboard firmware                          | Hardware setup done during boot; not active here.                  |
| **User Loader**  | `ntdll!LdrInitializeThunk`    | `ntdll.dll`                                   | Loads DLLs, resolves imports, runs `WinMain`.                      |
| **Hardware**     | CPU / MMU / Caches            | Physical machine                              | Executes user code, handles memory translation.                    |


